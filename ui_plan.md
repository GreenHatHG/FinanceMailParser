## 一、总体架构 (High-Level Architecture)
采用 单体应用 (Monolithic Application) 模式。Streamlit 既是前端也是后端，直接运行在本地 Python 运行时中。

## 二、功能

### 2.1.邮箱配置管理
提供一个专门的配置页面，用于输入和保存信息:邮箱地址、授权码
1. 持久化到本地后下次打开可以直接读取
2. 支持删除修改等常见操作
3. 提供测试连接的操作,保证填入的邮箱地址和授权码正确

### 2.2.日期范围选择器+下载信用卡账单
描述: 将下载信用卡账单的功能添加到前端， 并提供日期范围选择器，提供快捷选择日期方式,比如本月,最近三个月等常见日期选择方式.
只涉及信用卡账单的下载，不涉及到微信和支付宝账单的逻辑

### 2.3.现有账单的查看
下载了信用卡账单之后，添加一个地方专门去看看现在有哪一些账单
点击账单也可以直接查看里面的内容
另外添加一个入口在下载信用卡账单按钮下载完成之后，点击就可以直接跳过去看看有哪一些账单了。

### 2.4.下载微信&支付宝账单
在下载信用卡账单页面，添加下载微信和支付宝账单
微信和支付宝是下载最新的一封就行了，不用按时间去筛选
下载之后，还得输入解压密码，所以这里前端需要提供一个地方输入解压密码
这里还有个逻辑，如果本地已经存在了微信或者支付宝账单，就不要重复下载。因为可能下载链接只能下载一次
重复检测的实现：递归检查微信和支付宝的解压目录有没有csv文件

### 2.5.检查所有的账单解析是否已支持时间过滤
检查一下解析信用卡微信支付宝账单的函数是否已支持时间过滤
而且所有的过滤都走同一个过滤函数，避免产生分歧

### 2.6.解析所有已下载账单
将下载好的账单解析，包括信用卡，微信和支付宝
解析出来的格式目前只支持beancount
也得传入时间，但是这里的时间是产生账单的时间，也就是先过滤一下，不在时间范围内的账单，只留下需要的
实现前后端

### 2.7.beancount账户智能化处理
基于前端生成的原始 Beancount 文件，实现「AI 赋能 + 数值安全脱敏 + 历史账单参考 + 支出账户自动填充 + 真实数值恢复 + AI 填充项待人工核验」的闭环能力

#### 2.7.1 前端选择beancount并预览发送的内容
1. 自动选择已经解析出来的最新的beancount账单，这个在前端展示已经选择到了
2. 前端支持勾选本地多个「历史 Beancount 账单文件」，并将这些历史文件作为「参考库」附加到本次处理流程中
3. 基于上述所有的beancount账单，构建一个prompt，发送前在前端预览后再发送给ai处理（仅前端，后端这次先不做）

#### 2.7.2 金额脱敏与恢复
1. 对「所有 Bean 文件」中 所有金额数值 进行全量脱敏处理。
2. 脱敏规则：仅对「数字金额」做替换，保留所有其他内容完全不变（包括交易日期、交易描述、已有的账户名、币种、注释、Beancount 语法符号、收支正负号等）
3. 脱敏特性：必须是 可逆脱敏 → 脱敏后的数值带有「唯一映射标记」，后续能 100% 精准恢复为原始真实数值，无任何误差、无任何数据丢失；
4. AI 完成支出账户的填充后，立即对整个 Bean 文件执行「脱敏数值还原」操作；还原规则：基于脱敏时的「唯一映射标记」，将所有脱敏的占位符金额，100% 精准恢复为原始的真实金额数值；
5. ai发送这次不实现，仅占位

#### 2.7.3 ai配置页面和发送
加一个新的页面用于保存 AI 的配置
利用https://github.com/BerriAI/litellm发送前面生成的prompt给ai，支持常见的格式，比如openai，gemini等
要默认失败之后重试发送，重试的次数和间隔可以在前端配置
前端展示 AI 调用的耗时，有没有错误，重试的次数等等信息

#### 2.7.4 对账功能
发送账单给ai填充后，跟发送前的比对一下，看看有没有缺失，金额对不对，备注对不对等等，ai可能返回了不完整的内容，或者篡改了内容