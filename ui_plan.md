## 一、总体架构 (High-Level Architecture)
采用 单体应用 (Monolithic Application) 模式。Streamlit 既是前端也是后端，直接运行在本地 Python 运行时中。

## 二、功能

### 2.1.邮箱配置管理
提供一个专门的配置页面，用于输入和保存信息:邮箱地址、授权码
1. 持久化到本地后下次打开可以直接读取
2. 支持删除修改等常见操作
3. 提供测试连接的操作,保证填入的邮箱地址和授权码正确

### 2.2.日期范围选择器+下载信用卡账单
描述: 将下载信用卡账单的功能添加到前端， 并提供日期范围选择器，提供快捷选择日期方式,比如本月,最近三个月等常见日期选择方式.
只涉及信用卡账单的下载，不涉及到微信和支付宝账单的逻辑

### 2.3.现有账单的查看
下载了信用卡账单之后，添加一个地方专门去看看现在有哪一些账单
点击账单也可以直接查看里面的内容
另外添加一个入口在下载信用卡账单按钮下载完成之后，点击就可以直接跳过去看看有哪一些账单了。

### 2.4.下载微信&支付宝账单
在下载信用卡账单页面，添加下载微信和支付宝账单
微信和支付宝是下载最新的一封就行了，不用按时间去筛选
下载之后，还得输入解压密码，所以这里前端需要提供一个地方输入解压密码
这里还有个逻辑，如果本地已经存在了微信或者支付宝账单，就不要重复下载。因为可能下载链接只能下载一次
重复检测的实现：递归检查微信和支付宝的解压目录有没有csv文件

### 2.5.检查所有的账单解析是否已支持时间过滤
检查一下解析信用卡微信支付宝账单的函数是否已支持时间过滤
而且所有的过滤都走同一个过滤函数，避免产生分歧

### 2.6.解析所有已下载账单
将下载好的账单解析，包括信用卡，微信和支付宝
解析出来的格式目前只支持beancount
也得传入时间，但是这里的时间是产生账单的时间，也就是先过滤一下，不在时间范围内的账单，只留下需要的
实现前后端

### 2.7.beancount账户智能化处理
基于前端生成的原始 Beancount 文件，实现「AI 赋能 + 数值安全脱敏 + 历史账单参考 + 支出账户自动填充 + 真实数值恢复 + AI 填充项待人工核验」的闭环能力

#### 2.7.1 前端选择beancount并预览发送的内容
1. 自动选择已经解析出来的beancount账单，这个在前端也得展示
2. 前端支持勾选本地多个「历史 Beancount 账单文件」，并将这些历史文件作为「参考库」附加到本次处理流程中
3. 基于上述所有的beancount账单，构建一个prompt，发送前在前端预览后再发送给ai处理


#### 2.7.2
2. 所有历史 Bean 文件仅作为 AI 学习 / 参考使用，不会修改历史文件本身，也不会将历史文件内容写入最终生成的文件，仅提供「支出分类习惯、账户命名规则、消费类型匹配」的参考价值；
3. 对「所有 Bean 文件」中 所有金额数值 进行全量脱敏处理。脱敏规则：仅对「数字金额」做替换，保留所有其他内容完全不变（包括交易日期、交易描述、已有的账户名、币种、注释、Beancount 语法符号、收支正负号等）；脱敏特性：必须是 可逆脱敏 → 脱敏后的数值带有「唯一映射标记」，后续能 100% 精准恢复为原始真实数值，无任何误差、无任何数据丢失；
4. 仅针对「本次生成的原始 Bean 主文件」中 支出类交易里「缺失的支出账户」 进行填充；
5. AI 填充依据：优先参考「你自选附加的历史 Bean 文件」的个人记账习惯；填充合规性：AI 填充的支出账户名称，严格遵循 Beancount 的标准账户语法规则（分层结构、英文冒号分隔、标准分类前缀如 Expenses:/Income:），不会生成非法账户名导致文件解析失败；
6. AI 完成支出账户的填充后，立即对整个 Bean 文件执行「脱敏数值还原」操作；还原规则：基于脱敏时的「唯一映射标记」，将所有脱敏的占位符金额，100% 精准恢复为原始的真实金额数值；
7. 对 AI 自动填充的内容打 TODO 标记，强制人工确认